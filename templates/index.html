<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <title>Digito</title>

    <style>

        .main {
            /* border: 2px solid red; */
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* align-items: center; */
            height: 400px; 
            /* border: 2px solid red; */
        }

        #container {
            position: relative;
            width: 600px;
            /* border: 2px solid red; */
        }

        #sketchpad {
            border: 5px solid #077;
        }

        #thumbnail {
            border: 1px solid #077;
        }

        #result {
            /* font-size: 128pt; */
            /* float: right; */
            /* width: 270px; */
            height: 20px;
            /* border: 5px solid #fff; */
            /* text-align: center; */
            /* line-height: 280px; */
            /* border: 2px solid red; */
            /* border: 5px solid #077; */
        }  
        .number{

        }

    </style>
</head>

<body>
    <!-- Navbar -->

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">Navbar</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#">Home</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#">Link</a>
              </li>
              <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                  Dropdown
                </a>
                <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <li><a class="dropdown-item" href="#">Action</a></li>
                  <li><a class="dropdown-item" href="#">Another action</a></li>
                  <li><hr class="dropdown-divider"></li>
                  <li><a class="dropdown-item" href="#">Something else here</a></li>
                </ul>
              </li>
              <li class="nav-item">
                <a class="nav-link disabled">Disabled</a>
              </li>
            </ul>
            <form class="d-flex">
              <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
              <button class="btn btn-outline-success" type="submit">Search</button>
            </form>
          </div>
        </div>
      </nav>

    <!-- Navbar -->

    <!-- card -->

    <!-- card -->

    
    <p style="font-family: cursive; text-align: center; font-size: 30px; margin-top: 30px;">
            MNIST Handwritten Digit Recognition
    </p>
    <br />

    
    
    <div class="main">
        
        <div class="container">
            <div class="number" style="font-size: 50px; font-weight: bold;width: 280px;display: flex;justify-content: center;"></div>
            
            <div class="row">
                <div class="col">
                    <canvas id="sketchpad" width="280" height="280">Sorry, your browser is not supported.</canvas>
                </div>
                
                <div class="col">
                    <div id="result">

                    </div>
                </div>

                <div class="col clr_btn">
                    

                </div>
                <div class="w-100"></div> <!--static-->


                <!-- <div class="col">Column4</div> -->
            </div>



               
                <div>
                    
                </div>


        </div>
    </div>
    

</body>



<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
<script>
    let touchend;
    window.addEventListener('load', () => {
        // get the canvas element and its context
        const canvas = document.getElementById('sketchpad');

        const context = canvas.getContext('2d');
        let canvasOffset = getOffsetSum(canvas);

        const footprint = {
            width: 28,
            height: 28
        };

        let isRecognized = false;
        const zoom = 10;

        const clearer = function clearer() {
            context.clearRect(0, 0, footprint.width * zoom, footprint.height * zoom);
            // document.getElementById('result').innerText = '';
            isRecognized = false;
        };

        clearer();

        function getOffsetSum(elem) {
            let top = 0;
            let left = 0;
            while (elem) {
                top = top + parseInt(elem.offsetTop)
                left = left + parseInt(elem.offsetLeft)
                elem = elem.offsetParent
            }

            return { top, left }
        }

        // create a drawer which tracks touch movements
        const drawer = {
            isDrawing: false,
            touchstart(coors) {
                context.beginPath();
                context.lineWidth = 20;
                context.lineCap = "round";
                context.moveTo(coors.x - canvasOffset.left, coors.y - canvasOffset.top);
                this.isDrawing = true;
            },
            touchmove(coors) {
                if (this.isDrawing) {
                    try {
                        clearTimeout(touchend)
                    } catch (e) {

                    }
                    if (isRecognized) {
                        clearer();
                    }
                    context.lineTo(coors.x - canvasOffset.left, coors.y - canvasOffset.top);
                    context.stroke();
                }
            },
            touchend(coors) {
                if (this.isDrawing) {
                    this.touchmove(coors);
                    this.isDrawing = false;
                }

                touchend = setTimeout(() => {
                    recognizeN().then(() => {
                        clearer();
                    })

                }, 300)
            }
        };
        // create a function to pass touch events and coordinates to drawer
        function draw(event) {
            let type = null;
            // map mouse events to touch events
            switch (event.type) {
                case "mousedown":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchstart";
                    break;
                case "mousemove":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchmove";
                    break;
                case "mouseup":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchend";
                    break;
            }

            // touchend clear the touches[0], so we need to use changedTouches[0]
            let coors;
            if (event.type === "touchend") {
                coors = {
                    x: event.changedTouches[0].pageX,
                    y: event.changedTouches[0].pageY
                };
            }
            else {
                // get the touch coordinates
                coors = {
                    x: event.touches[0].pageX,
                    y: event.touches[0].pageY
                };
            }
            type = type || event.type
            // pass the coordinates to the appropriate handler
            drawer[type](coors);
        }

        // detect touch capabilities
        const touchAvailable = ('createTouch' in document) || ('ontouchstart' in window);

        // attach the touchstart, touchmove, touchend event listeners.
        if (touchAvailable) {
            canvas.addEventListener('touchstart', draw, false);
            canvas.addEventListener('touchmove', draw, false);
            canvas.addEventListener('touchend', draw, false);
        }
        // attach the mousedown, mousemove, mouseup event listeners.
        else {
            canvas.addEventListener('mousedown', draw, false);
            canvas.addEventListener('mousemove', draw, false);
            canvas.addEventListener('mouseup', draw, false);
        }

        window.addEventListener("resize", event => {
            event.preventDefault();
            canvasOffset = getOffsetSum(canvas);
        }, false);

        // prevent elastic scrolling
        document.body.addEventListener('touchmove', event => {
            event.preventDefault();
        }, false); // end body.onTouchMove

        // Clear canvas
        document.getElementById('sketchClearButton').addEventListener('click', event => {
            event.preventDefault();
            clearer();
        }, false)

        // Number recognizer
        function recognizeN() {
            return new Promise((resolve, reject) => {
                if (isRecognized) return;
                let imgData = context.getImageData(0, 0, 280, 280);

                grayscaleImg = imageDataToGrayscale(imgData);
                const boundingRectangle = getBoundingRectangle(grayscaleImg, 0.01);
                const trans = centerImage(grayscaleImg); // [dX, dY] to center of mass

                //console.log(grayscaleImg);
                //console.log(boundingRectangle);
                //console.log(trans);

                // copy image to hidden canvas, translate to center-of-mass, then
                // scale to fit into a 200x200 box (see MNIST calibration notes on
                // Yann LeCun's website)
                const canvasCopy = document.createElement("canvas");
                canvasCopy.width = imgData.width;
                canvasCopy.height = imgData.height;
                const copyCtx = canvasCopy.getContext("2d");
                const brW = boundingRectangle.maxX + 1 - boundingRectangle.minX;
                const brH = boundingRectangle.maxY + 1 - boundingRectangle.minY;
                const scaling = 190 / (brW > brH ? brW : brH);
                // scale
                copyCtx.translate(canvas.width / 2, canvas.height / 2);
                copyCtx.scale(scaling, scaling);
                copyCtx.translate(-canvas.width / 2, -canvas.height / 2);
                // translate to center of mass
                copyCtx.translate(trans.transX, trans.transY);

                copyCtx.drawImage(context.canvas, 0, 0);

                // now bin image into 10x10 blocks (giving a 28x28 image)
                imgData = copyCtx.getImageData(0, 0, 280, 280);
                grayscaleImg = imageDataToGrayscale(imgData);
                // console.log(grayscaleImg);

                const nnInput = new Array(784);
                const nnInput2 = [];
                for (var y = 0; y < 28; y++) {
                    for (var x = 0; x < 28; x++) {
                        let mean = 0;
                        for (let v = 0; v < 10; v++) {
                            for (let h = 0; h < 10; h++) {
                                mean += grayscaleImg[y * 10 + v][x * 10 + h];
                            }
                        }
                        mean = (1 - mean / 100); // average and invert
                        nnInput[x * 28 + y] = (mean - .5) / .5;
                    }
                }



                // for visualization/debugging: paint the input to the neural net.
                //if (document.getElementById('preprocessing').checked == true) {
                if (true) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(copyCtx.canvas, 0, 0);
                    for (var y = 0; y < 28; y++) {
                        for (var x = 0; x < 28; x++) {
                            const block = context.getImageData(x * 10, y * 10, 10, 10);
                            const newVal = 255 * (0.5 - nnInput[x * 28 + y] / 2);
                            nnInput2.push(Math.round((255 - newVal) / 255 * 100) / 100);
                            for (let i = 0; i < 4 * 10 * 10; i += 4) {
                                block.data[i] = newVal;
                                block.data[i + 1] = newVal;
                                block.data[i + 2] = newVal;
                                block.data[i + 3] = 255;
                            }
                            context.putImageData(block, x * 10, y * 10);
                        }
                    }
                }


                //console.log(nnInput2);
                // const output = nn(nnInput2);
                // console.log(nnInput2);


                // #############################################################################################
                // #############################################################################################

                // const output =5
                // document.getElementById('result').innerText = output.toString();

                // isRecognized = true;
                // resolve()
                net(nnInput2)
            })

        }
        // document.getElementById('sketchRecogniseButton').addEventListener('click', recognizeN, false)
    }, false); // end window.onLoad

    /* Controller */
    /* Imported model because < 1mb */
  

    function net(input) {
        console.log(input);
        
        // const csrftoken = getCookie('csrftoken');
        // console.log(csrftoken);
        data = JSON.stringify({
            'array': input
        })
        let p = "j";
        // debugger;
        // console.log(data);  
        
        fetch('http://127.0.0.1:5000/digit', {
            method: 'POST',
            body: data,
            headers: {
                'Accept': 'application/json, text/plain',
                'Content-Type': 'application/json',
                // "X-CSRFToken": csrftoken
            },

        }).then(response => response.text())
            .then(pred_val => {
                // console.log(pred_val);
                // return pred_val
                // console.log(pred_val);
                
                pred_value = JSON.parse(pred_val)
                // console.log(pred_value);
                result_box =  document.querySelector('#result')
                
                let res_map_obj = {
//                     'cnn_res':'CNN',
                    'l_r_res':'Logestic Regression',
                    'mnb_res':'Multi_N Naive Bayes'}

                for (const key in pred_value) {
                    doc = document.createElement("div")
                    // console.log(typeof parseInt(pred_value[key]));
                    clear_btn = document.getElementsByClassName('clr_btn')
                    console.log(clear_btn[0]);
                    
                    clr_btn_dom = `<button type="button" class="btn clr btn-primary mx-auto" id="sketchClearButton" onclick="window.location.reload()">clear</button>`

                    check = verify(pred_value[key])
                    console.log(check);
                    
                    if(check){
                        class_name = 'alert-success'
                    }
                    else{
                        class_name = 'alert-danger'
                    }

                    new_doc = document.createElement("div")
                    new_doc.className = `alert ${class_name}`
                    // document.setAttribute("role", "alert");
                    // new_doc

                    
                    
                    new_doc.innerHTML = `${res_map_obj[key]}-${pred_value[key]}`
                    clear_btn[0].innerHTML = clr_btn_dom

                    result_box.appendChild(new_doc)
                    // new_doc=`<div class="alert ${class_name}" role="alert">${key}-${pred_value[key]}</div>`

                    // doc.append(new_doc)
                    
                    // result_box.innerHTML = new_doc
                }
                
                
                // cnn_response = pred_value['cnn_res']
                // lr_response = pred_value['l_r_res']
                // mnb_response = pred_value['mnb_res']
                
                // res_arr = [cnn_response,lr_response,mnb_response]
                // res_arr.forEach(element => {    
                //     check = verify(pred_val)
                //     if(check){
                //         class_name = 'alert alert-success'
                //         doc = `<div class="alert alert-success" role="alert">
                //     }
                // });
                
                // cnn_check = verify(pred_val)
                // lr_check = verify(pred_val)
                // mnb_check = verify(pred_val)



                // result_box.innerText = pred_val
                // isRecognized = true;
                // verify(pred_val)
                
            })


    }

    // function tf(){
    //     return true
    // }


    /***********/
    /* imgUtil */
    /***********/







    // computes center of mass of digit, for centering
    // note 1 stands for black (0 white) so we have to invert.
    function centerImage(img) {
        var meanX = 0;
        var meanY = 0;
        var rows = img.length;
        var columns = img[0].length;
        var sumPixels = 0;
        for (var y = 0; y < rows; y++) {
            for (var x = 0; x < columns; x++) {
                var pixel = (1 - img[y][x]);
                sumPixels += pixel;
                meanY += y * pixel;
                meanX += x * pixel;
            }
        }
        meanX /= sumPixels;
        meanY /= sumPixels;

        var dY = Math.round(rows / 2 - meanY);
        var dX = Math.round(columns / 2 - meanX);
        return { transX: dX, transY: dY };
    }

    // given grayscale image, find bounding rectangle of digit defined
    // by above-threshold surrounding
    function getBoundingRectangle(img, threshold) {
        var rows = img.length;
        var columns = img[0].length;
        var minX = columns;
        var minY = rows;
        var maxX = -1;
        var maxY = -1;
        for (var y = 0; y < rows; y++) {
            for (var x = 0; x < columns; x++) {
                if (img[y][x] < threshold) {
                    if (minX > x) minX = x;
                    if (maxX < x) maxX = x;
                    if (minY > y) minY = y;
                    if (maxY < y) maxY = y;
                }
            }
        }
        return { minY: minY, minX: minX, maxY: maxY, maxX: maxX };
    }

    // take canvas image and convert to grayscale. Mainly because my
    // own functions operate easier on grayscale, but some stuff like
    // resizing and translating is better done with the canvas functions
    function imageDataToGrayscale(imgData) {
        var grayscaleImg = [];
        for (var y = 0; y < imgData.height; y++) {
            grayscaleImg[y] = [];
            for (var x = 0; x < imgData.width; x++) {
                var offset = y * 4 * imgData.width + 4 * x;
                var alpha = imgData.data[offset + 3];
                // weird: when painting with stroke, alpha == 0 means white;
                // alpha > 0 is a grayscale value; in that case I simply take the R value
                if (alpha == 0) {
                    imgData.data[offset] = 255;
                    imgData.data[offset + 1] = 255;
                    imgData.data[offset + 2] = 255;
                }
                imgData.data[offset + 3] = 255;
                // simply take red channel value. Not correct, but works for
                // black or white images.
                grayscaleImg[y][x] = imgData.data[y * 4 * imgData.width + x * 4 + 0] / 255;
            }
        }


        return grayscaleImg;
    }


    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }
    document.querySelector('.number').innerHTML = randomNumber(1,9)

    function verify(pred_val){
        let given_num = document.querySelector('.number').innerHTML
        
        if (pred_val == parseInt(given_num)){
            return true
            // document.getElementById('result').style.backgroundColor = "green"
            
        }
        else{
            // console.log(false);
            // document.getElementById('result').style.backgroundColor = "red"
            return false
            
        }
    }

    
</script>

</html>
